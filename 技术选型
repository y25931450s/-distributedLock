概述
在分布式系统中，JDK 原生的并发锁工具在一些场景就无法满足我们的要求，所以我们要使用分布式锁

要实现分布式锁，就必须依赖中间件，数据库、redis、zookeeper等。本次主要实现redis和zookeeper的分布式锁



一、基于数据库实现的分布式锁

数据库实现分布式锁的优点

直接借助数据库，容易理解，不需要引入中间件，架构简单。

数据库实现分布式锁的缺点

会有各种各样的问题，在解决问题的过程中会使整个方案变得越来越复杂。

操作数据库需要一定的开销，性能问题需要考虑。



二、基于redis的分布式锁

使用缓存实现分布式锁的优点

性能好，redis本身的读写性能很高，因此基于redis的分布式锁效率比较高。

使用缓存实现分布式锁的缺点

实现过于复杂，需要考虑的因素太多，依赖中间件，分布式环境下可能会有节点数据同步问题，可靠性有一定的影响



三、基于Zookeeper实现的分布式锁

使用Zookeeper实现分布式锁的优点

有效的解决单点问题，不可重入问题，非阻塞问题以及锁无法释放的问题。实现起来较为简单。　zk分布式锁，获取不到锁，注册个监听器即可，不需要不断主动尝试获取锁，性能开销较小

使用Zookeeper实现分布式锁的缺点

性能上不如使用缓存实现分布式锁。 需要对ZK的原理有所了解。



分布式锁要求：
互斥
分布式系统中运行着多个节点，必须确保在同一时刻只能有一个节点的一个线程获得锁，这是最基本的一点。

避免死锁
分布式系统中，可能产生死锁的情况要相对复杂一些。分布式系统是处在复杂网络环境中的，当一个节点获取到锁，如果它在释放锁之前挂掉了，或者因网络故障无法执行释放锁的命令，都会导致其他节点无法申请到锁。

因此分布式锁有必要设置时效，确保在未来的一定时间内，无论获得锁的节点发生了什么问题，最终锁都能被释放掉。

性能
对于访问量大的共享资源，如果针对其获取锁时造成长时间的等待，导致大量节点阻塞，是绝对不能接受的。

所以设计分布式锁时要能够掌握锁持有者的动态，若判断锁持有者处于不活动状态，要能够强制释放其持有的锁。
此外，排队等待锁的节点如果不知道锁何时会被释放，则只能隔一段时间尝试获取一次锁，这样无法保证资源的高效利用，因此当锁释放时，要能够通知等待队列，使一个等待节点能够立刻获得锁。

可重入
考虑到一些应用场景和资源的高效利用，锁要设计成可重入的，就像 JDK 中的 ReentrantLock 一样，同一个线程可以重复拿到同一个资源的锁。

实现：
Redis分布式锁

经过调研，redis的分布式锁将依据开源的Redisson进行实现



Redisson是一个在Redis的基础上实现的Java驻内存数据网格（In-Memory Data Grid）。它不仅提供了一系列的分布式的Java常用对象，还提供了许多分布式服务



优势：

1.高可用：Redisson可以设置哨兵模式和集群模式保证了系统的高可用

2.可重入：避免死锁

3.避免任务阻塞未完成锁自动释放：在成功获取到锁的情况下，为了避免业务中对共享资源的操作还未完成，锁就被释放掉了，需要定期（锁失效时间的三分之一）刷新锁失效的时间，这里 Redisson 使用了 Netty 的 TimerTask、Timeout 工具来实现该任务调度。

4.防止线程无限请求锁：如果没有获得锁，则需等待锁被释放，并通过 Redis 的 channel 订阅锁释放的消息，如果锁当前是被占用的，那么等待释放锁的消息，具体实现使用了 JDK 并发的信号量工具 Semaphore 来阻塞线程，当锁释放并发布释放锁的消息后，信号量的 release() 方法会被调用，此时被信号量阻塞的等待队列中的一个线程就可以继续尝试获取锁了



zookeeper分布式锁


zookeeper的分布式锁将依靠开源的Curator进行实现

Curator 对zookeeper 提供了丰富的封装，异常处理， master选举，分布式锁，分布式基数等，很方便的为日常生产所使用。这次主要使用curator的InterProcessMutex这种分布式可重入锁

优势：

重试机制：Curator支持可插拔式的(pluggable)重试机制。所有会产生可恢复异常的 ZooKeeper 操作都会在配置好的重试策略下得到重试
 连接状态监视：Curator 不断监视ZooKeeper 连接的状态，Curator 用户可以监听连接状态变化并相应的作出回应
可重入：避免死锁
避免线程阻塞：临时顺序节点并设置session expired，保证了最先申请锁的排在最开始，同一时刻只能有一个节点的一个线程获得锁，一旦客户端失去连接后或会话过期，则就会自动清除该节点
